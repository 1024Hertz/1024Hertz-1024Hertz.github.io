---
title: 事务的四种隔离级别
tags:
  - 数据库
  - 事务
---

# 事务的四种隔离级别
## 数据库事务的隔离级别有4种
* 由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 
* 在事务的并发操作中可能会出现脏读，不可重复读，幻读

## Read uncommitted
* 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据
* 事务回滚会导致脏读

## Read committed
* 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据
* 一个事务范围内两个相同的查询却返回了不同数据会导致不可重复读
* 解决脏读问题

## Repeatable read
* 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
* 幻读问题对应的是插入INSERT操作，而不是UPDATE操作

## Serializable
* 序列化，事务串行化顺序执行
* 避免脏读、不可重复读与幻读
* 效率低下，比较耗数据库性能

# 数据库事务配置
* 大多数数据库默认的事务隔离级别是Read committed
* Mysql的默认隔离级别是Repeatable read
* select语句会自动获取共享锁
* update/insert/delete会自动获取排它锁
* 一个事务中的一行记录的共享锁被拿走，其他事务只能获取该行的共享锁，不能获取排它锁
* 一个事务中的一行记录的排它锁被拿走，其他事务不能获取该行的共享锁和排它锁

# 第一类更新
* 待补充

# 第二类更新
* 待补充

# 最佳实践
* 通常，对于绝大多数的应用程序来说，可以优先考虑将数据库系统的隔离级别设置为读已提交（Read Committed）  
* 这能够在避免脏读的同时保证较好的并发性能。尽管这种事务隔离级别会导致不可重复读、幻读和第二类丢失更新等并发问题  
* 但较为科学的做法是在可能出现这类问题的个别场合中，由应用程序主动采用悲观锁或乐观锁来进行事务控制
